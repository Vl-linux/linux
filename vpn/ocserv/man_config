### следующие директивы не изменяются с перезагрузкой сервера.
# Метод аутентификации пользователей. 
# Чтобы потребовать, чтобы несколько методов использовались для пользователя для входа в систему, добавьте несколько подлинных директив. 
# (Несколько значений должны успешно выполниться).
# Доступные параметры: сертификат, plain, pam, радиус, gssapi.
# Примечание, методы аутентификации, использующие пароли, не могут быть комбинированы (например: plain, pam или методы радиуса).
#
# сертификат:
# Это указывает, что все соединительные пользователи должны представить сертификат.
# имя пользователя и группа пользователей будут тогда извлечены из него (см. cert-user-oid и cert-group-oid). 
# Сертификат, который будет принят, это должно быть подписано сертификатом CA, столь же указанным в 'ca-cert', 
# и это не должно быть перечислено в CRL, как определено 'crl' опцией.
#
# pam[gid-min=1000]:
# Эта включенная аутентификация PAM пользователя. 
# Опция используется auto-select-group опцией для выбора минимального действительного идентификатора группы.
#
#plain[passwd=/etc/ocserv/ocpasswd,otp=/etc/ocserv/users.otp]
# простая опция требует определения файла паролей, который содержит записи следующего формата:
# "username:groupname1,groupname2:encoded-password"
# Одна запись должна быть перечислена на строку, и 'ocpasswd' должен использоваться для генерации записей паролей.
# 'otp' подопция позволяет определять файл паролей, который будет использоваться для одноразовых паролей; 
# формат файла описан в https://github.com/archiecobbs/mod-authn-otp/wiki/UsersFile
#
# radius[config=/etc/radiusclient/radiusclient.conf,groupconfig=true,nas-identifier=name]:
# опция радиуса требует определения freeradius-клиентского конфигурационного файла. 
# Если groupconfig опция будет установлена, то config-per-user/group будет переопределен, и вся конфигурация будет считана из радиуса. 
# Это также включает Acct-Interim-Interval и значения Тайм-аута Сессии.
#
# См. doc/README-radius.md для поддерживаемых атрибутов конфигурации радиуса.
#
# gssapi[keytab=/etc/key.tab,require-local-user-map=true,tgt-freshness-time=900]
# gssapi опция позволяет использовать методы аутентификации, поддерживаемые GSSAPI, такие как билеты Kerberos с ocserv. 
# Это должно лучше всего использоваться в качестве альтернативы PAM (т.е. иметь pam в auth и gssapi в enable-auth), 
# чтобы позволить пользователям с билетами и без билетов входить в систему. 
# Значение по умолчанию для require-local-user-map верно. 
# 'Tgt-freshness-time', если установлено, это потребовало бы, чтобы билеты TGT представили быть выпущенными в обеспеченном числе секунд. 
# ЭТа опция используется для ограничения логинов, даже если KDC предоставляет долгому времени билеты TGT.
#
#auth = "pam"
#auth = "pam[gid-min=1000]"
#auth = "plain[passwd=./sample.passwd,otp=./sample.otp]"
auth = "plain[passwd=./sample.passwd]"
#auth = "certificate"
#auth = "radius[config=/etc/radiusclient/radiusclient.conf,groupconfig=true]"

# Определяют альтернативные методы аутентификации, которые достаточны для аутентификации. 
# Таким образом, если установлено, любой из методов включил, будет достаточно для входа в систему, 
# соответствующий из основных 'auth' записей.
# Когда несколько опций присутствуют, они ИЛИ составлены (любой из них, следование позволяет вход в систему).
#enable-auth = "certificate"
#enable-auth = "gssapi"
#enable-auth = "gssapi[keytab=/etc/key.tab,require-local-user-map=true,tgt-freshness-time=900]"

# доступные методы:
# радиус: может быть объединен с любым методом аутентификации, он предоставляет радиус, 
# считающий доступным пользователям (см. также stats-report-time).
#
# pam: может быть объединен с любым методом аутентификации, он обеспечивает проверку имени соединяющегося пользователя с помощью PAM. 
# Это является лишним для использования этого метода, когда аутентификация уже является PAM.
#
# Только один метод может быть определен.
#acct = "radius[config=/etc/radiusclient/radiusclient.conf]"

# слушает-хост Использование для ограничения определенным IPs или IPs определенного имени узла.
#listen-host = [IP|HOSTNAME]

# Когда сервер имеет динамический адрес DNS (который может измениться), должен установить это в true, чтобы клиент снова соединился.
#listen-host-is-dyndns = true

# TCP and UDP port number
tcp-port = 443
udp-port = 443

# Принимают соединения с помощью файла сокета. 
# Это принимает HTTP-соединения (т.е. без SSL/TLS в отличие от его дубликата TCP) и использует его в качестве основного канала. 
# Эта опция экспериментальна, и она имеет много известных проблем.
# * Это может только быть объединено с аутентификацией сертификата, 
# когда информация о приемном канале через протокол прокси (см. listen-proxy-proto),
# * Это не может получить ключи, необходимые для сессии DTLS (следовательно нет поддержки dtls-psk)
# * Это не может осуществить структурирование пакетов SSL/TLS, и это повреждает предположения, сохраненные несколькими openconnect клиентами.
# Эта опция не рекомендуется для использования и может быть удалена в будущем.
#
#listen-clear-file =/var/run/ocserv-conn.socket

# рабочие процессы будут выполнены от этого пользователя. Это должно быть уникально (другие сервисы не должны быть, выполненны от этого пользователя).
run-as-user = nobody
run-as-group = daemon

# снабжают сокетом файл, используемый для "IPC" с "occtl". Это необходимо установить только при использовании больше, чем одного сервера.
#occtl-socket-file = /var/run/occtl.socket

# файл сокета, используемый для сервера (основной рабочий) IPC, будет добавлен с.PID
# Это должно быть доступно в chroot среде (если таковые имеются), таким образом, это лучше всего определяется относительно к chroot каталогу.
socket-file = /var/run/ocserv-socket

# каталог сервера по умолчанию. Не требует никаких существующих устройств.
#chroot-dir = /var/lib/ocserv

# ключ и сертификаты о сервере
# ключ может быть файлом или любым URL, поддерживаемым GnuTLS 
# например, tpmkey:uuid=xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxx;storage=user или or pkcs11:object=my-vpn-key;object-type=private
#
# файл сертификата сервера может содержать единственный сертификат или отсортированную цепочку сертификата.
# могут быть несколько сертификатов сервера и ключевые для сервера директивы, но каждый ключ должен соответствовать предыдущему сертификату.
# файлы сертификата будут перезагружены, когда выполнено оперативное обновление сертификата (они проверяются и периодически перезагружаются;
# сигнал SIGHUP к основному серверу вызовет перезагрузку).

#server-cert = /etc/ocserv/server-cert.pem
#server-key = /etc/ocserv/server-key.pem
server-cert = ../tests/certs/server-cert.pem
server-key = ../tests/certs/server-key.pem

# параметры Diffie-Hellman. 
# Необходим только, если для старой версии 3.6.0 из GnuTLS для поддержки DHE ciphersuites.
# Может быть сгенерирован с помощью:
# certtool --generate-dh-params --outfile /etc/ocserv/dh.pem
#dh-params = /etc/ocserv/dh.pem

# В случае, если PKCS #11, TPM или при использовании зашифрованного ключа , PIN должны быть доступными в файлах. 
# srk-pin-file применим только к ключам TPM и является корневым ключом устройства хранения данных.
#pin-file = /etc/ocserv/pin.txt
#srk-pin-file = /etc/ocserv/srkpin.txt

# Пароль и PIN должен был разблокировать ключ в файле server-key.
# Необходимый только, если файл зашифрован или PKCS #11. Это - альтернативный метод в pin-file.
#key-pin = 1234

# The SRK PIN for TPM.
# Это - альтернативный метод к srk-pin-file.
#srk-pin = 1234

# Центр сертификации, который будет использоваться для проверки клиентских сертификатов (открытые ключи), 
# если аутентификация сертификата будет установлена.
#ca-cert = /etc/ocserv/ca.pem
ca-cert = ../tests/certs/ca.pem

### Все параметры конфигурации ниже этой строки перезагружаются на SIGHUP.
### опции выше, останется неизменным. 
### Однако отметьте , что сертификат сервера, ключевой для сервера, горячекатаный-params и опции сертификата CA, будет перезагружен, 
### если обеспеченный файл изменится на перезагрузке сервера. 
### Это позволяет вращение сертификата, но требует, чтобы ключ сервера остался тем же для бесшовной операции. 
### Если ключ сервера изменяется на перезагрузке, в течение времени перезагрузки могут быть сбои соединения.

# Разрешить ли seccomp/Linux изоляцию рабочего пространств имен. 
# Это ограничивает количество системных вызовов, позволенных рабочему процессу для сокращения повреждения от ошибки в рабочем процессе. 
# Это доступно в системах Linux по стоимости производительности.
# стоимость производительности составляет примерно 2% сверх времени трансфера (протестирован на Linux 3.17.8).
# эта изоляция процесса ограничивается определенными libc версиями, в которых была протестирована изоляция. 
# Если Вы получаете внезапные отказы на рабочих процессах, попытайтесь отключить эту опцию и сообщите об отказах, 
# наряду с системой и отладочной информацией в: https://gitlab.com/ocserv/ocserv/issues
isolate-workers = true

# баннер, который будет отображен на клиентах
#banner = "Welcome"

# Предельное число клиентов. Сброс или нулевое значение для неограниченного.
#max-clients = 1024
max-clients = 16

# Предел число идентичных клиентов (т.е. пользователи, соединяющиеся многократно). Сброс или нулевое значение для неограниченного.
max-same-clients = 2

# Когда сервер получает соединения от прокси, как haproxy, который поддерживает протокол прокси, устанавливает это получать корректные клиентские адреса. 
# Протокол прокси тогда ожидался бы в TCP или сокете UNIX (не UDP один). 
# Хотя и v1 и v2 версии протокола прокси поддерживаются, v2 версия рекомендуется, поскольку это более эффективно в парсинге.
#listen-proxy-proto = true

# Предел количество соединений клиента с каждыми X миллисекундами (X обеспеченное значение). нулевое значение не имеет предела.
#rate-limit-ms = 100

# Статистика сообщает о времени. 
# Число секунд, после которых каждый рабочий процесс сообщит о своей статистике использования (число байтов, переданных и т.д.). 
# Это полезно, когда учет используется как радиус.
#stats-report-time = 360

# Статистика сбрасывает время. Статистика промежутка времени, сохраненная процессами main/sec-mod, будет сброшена. 
# Эта статистика, показанная cmd 'occtl show stats'. 
# Для ежедневнго: 86400, еженедельно: 604800 Это не связано с stats-report-time.
server-stats-reset-time = 604800

# Проверка активности в секундах
keepalive = 32400

# Обнаружение недоступных узлов в секундах.
# Примечание, что, когда клиент находится за NAT, это значение должно быть достаточно коротким для предотвращения NAT, 
# разъединяющего его сеанс UDP с номером порта. Иначе клиенту можно было остановить его соединение UDP, в течение нескольких минут.
dpd = 90

# Обнаружение недоступных узлов для мобильных клиентов. 
# Это должно быть выше для предотвращения таких клиентов, являющихся, просыпающся слишком часто сообщениями DPD и сохраняют батарею.
# мобильные клиенты отличают от заголовка 'X-AnyConnect-Identifier-Platform'.
mobile-dpd = 1800

# При использовании DTLS и отсутствии трафика по UDP в течении длительного времени, вместо этого будет попытка отправить трафик по соединению TCP, 
# в попытке разбудить клиент, в случае что существует NAT, и соединение по UDP было удалено. 
# Если это сброшено, не пытайтесь использовать этот механизм восстановления.
switch-to-tcp-timeout = 25

# MTU discovery (DPD must be enabled)
try-mtu-discovery = false

# Если у Вас есть сертификат от CA, который предоставляет услугу OCSP, которую можно предоставить новому ответу состояния OCSP в рамках квитирования TLS. 
# Это будет препятствовать тому, чтобы клиент соединился независимо на сервере OCSP.
# можно периодически обновлять этот ответ с помощью:
# ocsptool --ask --load-cert=your_cert --load-issuer=your_ca --outfile response
# Удостоверяются, что Вы заменяете следующий файл атомарным способом.
#ocsp-response = /etc/ocserv/ocsp.der

# идентификатор объекта, который будет использоваться для чтения идентификатора пользователя в клиентском сертификате. 
# Идентификатор объекта должен быть частью Полезного OIDs сертификата DN:
#  CN = 2.5.4.3, UID = 0.9.2342.19200300.100.1.1, SAN(rfc822name)
cert-user-oid = 0.9.2342.19200300.100.1.1

# идентификатор объекта, который будет использоваться для чтения группы пользователей в клиентском сертификате. 
# Идентификатор объекта должен быть частью DN сертификата. Если пользователь может принадлежать нескольким группам, 
# то используйте несколько таких полей в DN сертификата. Полезные OIDs: 
#  OU (organizational unit) = 2.5.4.11 
#cert-group-oid = 2.5.4.11

# список аннулированых сертификатов, выпущенных 'ca-cert' выше.
# См. руководство для генерации пустого CRL первоначально. CRL будет перезагружаться периодически, когда ocserv обнаружит изменение в файле. 
# Вызвать использование перезагрузки SIGHUP.
#crl = /etc/ocserv/crl.pem

# это для включения согласования сжатия (LZS, LZ4).
#compression = true

# минимальный размер, под которым не будет сжат пакет.
# Который должен позволить низкую задержку для пакетов VoIP. Размер по умолчанию составляет 256 байтов. 
# Измените его, если клиенты обычно используют сжатие также VoIP с кодеками, которые превышают значение по умолчанию.
#no-compress-limit = 256

# Череда приоритетов
# GnuTLS; 
# обратите внимание, что SSL 3.0 отключен по умолчанию, поскольку нет никаких openconnect (и возможно anyconnect клиенты) использования тот протокол. 
# Последовательность ниже не осуществляет совершенную прямую секретность, чтобы быть совместимой с клиентами прежней версии.
#
# Примечание, что самые производительные ciphersuites являются моментом, является теми вовлекающими AES-GCM. 
# Они очень быстры в x86 и x86-64 аппаратных средствах, и кроме того не требуют никакого дополнения, таким образом в полной мере пользования MTU.
# Для этого, чтобы быть использованным в своих интересах, openconnect клиент должен использоваться, 
# и сервер должен быть скомпилирован против GnuTLS 3.2.7 или позже.
# Использование "gnutls-cli - benchmark-tls-ciphers", 
# для наблюдения различия в производительности с AES_128_CBC_SHA1 (значение по умолчанию для anyconnect клиентов) в системе.

tls-priorities = "NORMAL:%SERVER_PRECEDENCE:%COMPAT:-VERS-SSL3.0"

# Больше комбинаций в приоритетных последовательностях доступно, проверяет http://gnutls.org/manual/html_node/Priority-Strings.html
# Например, последовательность ниже осуществляет совершенную прямую секретность (PFS) на основном канале.
#tls-priorities = "NORMAL:%SERVER_PRECEDENCE:%COMPAT:-RSA:-VERS-SSL3.0:-ARCFOUR-128"

# Опция требует, чтобы установленный канал DTLS использовал тот же шифр в качестве основного канала TLS. 
# Это не может быть объединено с listen-clear-file, так как ciphersuite информация не доступна в этой конфигурации. 
# Отметьте также, что эта опция подразумевает, что опция dtls-прежней-версии является false; 
# эта опция не может быть осуществлена в legacy/compat протоколе.
#match-tls-dtls-ciphers = true

# время (в секундах), в течении которого клиенту разрешают оставаться на связи до аутентификации
auth-timeout = 240

# время (в секундах), в течении которого клиенту разрешают остаться неактивным (без трафика) прежде чем быть разъединенным. Сброс для отключения.
#idle-timeout = 1200

# время (в секундах), в течении которого клиенту разрешают остаться соединенным. Сброс для отключения. 
# Когда установлено клиент будет разъединен, будучи непрерывно соединенным для этого количества времени, 
# и его cookie будут делаться недействительным (т.е. переаутентификация будет требоваться).
#session-timeout = 86400

# время (в секундах), в течении которого мобильному клиенту разрешают оставаться неактивным (без трафик) прежде чем быть разъединенным. Сброс для отключения.
#mobile-idle-timeout = 2400

# время (в секундах), в течении которого клиенту не разрешают повторно подключиться после неудачной попытки аутентификации.
min-reauth-time = 300

# Запрет клиентов в ocserv работает с балловой системой оценки. 
# IP-адреса, которые получают счет по тому настроенному числу, запрещаются на min-reauth-time секунды. 
# По умолчанию попытка неправильного пароля является 10 точками, POST KKDCP является 1 точкой, и соединение является 1 точкой. 
# Обратите внимание, что из-за процессов различия, включаемых, количество точек не будет в реальном времени точный.
#
# запрет Счета не может надежно использоваться, когда получение проксировало соединения локально с сервера HTTP (т.е. когда listen-clear-file используется).
#
# нулевое значение для отключения.
max-ban-score = 80

# время (в секундах), в течении которого весь счет, сохраненный для клиента, сбрасывается.
ban-reset-time = 1200

# В случае, если требуется изменить точки по умолчанию.
#ban-points-wrong-password = 10
#ban-points-connection = 1
#ban-points-kkdcp = 1

# тайм-аут Cookie (в секундах)
# Как только клиент аутентифицируется, он предоставил cookie, с которым он может снова соединиться. 
# cookie станет недействительным, если не используется в этом тайм-ауте. 
# Этот cookie остается допустимым, в течение связанного времени пользователя, и после пользовательского разъединения, 
# это остается активным для этого количества времени. 
# То урегулирование должно позволить разумное количество времени для роуминга между различными сетями.
cookie-timeout = 300

# Если это включено (не рекомендуется) cookie останутся допустимыми даже после того, как пользователь вручную разъединится, и пока они не истекают. 
# Это может улучшить роуминг с некоторыми поврежденными клиентами.
#persistent-cookies = true

# Позволяется ли роуминг, т.е. если верный cookie ограничивается единственным IP-адресом и не может быть снова использован от различного IP.
deny-roaming = false

# Время  ReKey (в секундах) в течении которого ocserv попросит, чтобы клиент периодически обновлял ключи, как только это время истекает. 
# нулевое значение-  для отключения (заметь-те, что, некоторые клиенты перестали работать, если повторно вводят, отключен).
rekey-time = 172800

# ReKey method
Опции # Valid: ssl, новый туннель
# ssl: выполнит эффективное переквитирование на разрешении канала неразрывная связь во время повторно вводят.
# новый туннель: даст клиенту команду отбрасывать и восстанавливать канал.
# Используйте эту опцию, только если у соединяющихся клиентов есть проблемы с ssl 
rekey-method = ssl

# Сценарий для вызова, когда клиент соединяет и получает IP.
# следующие параметры передаются среде.
# EASON, VHOST, USERNAME, GROUPNAME, DEVICE, IP_REAL (реальный IP клиента),
# IP_REAL_LOCAL (локальный интерфейс IP соединенный клиент), IP_LOCAL (локальный IP в P-t-P соединении), IP_REMOTE (IP VPN клиента),
# IPV6_LOCAL (IPv6 локальный адрес, если существует и IPv4 и присвоенный IPv6), IPV6_REMOTE (IPv6 удаленный адрес), 
# IPV6_PREFIX и идентификатор (уникальный числовой идентификатор); ПРИЧИНОЙ может быть "подключение" или "разъединение".
# Кроме того, следующие переменные OCSERV_ROUTES (прикладные маршруты для этого клиента), 
# OCSERV_NO_ROUTES, OCSERV_DNS (серверы DNS для этого клиента), будет содержать разделенный список пространства серверов DNS или маршрутов. 
# Версия этих переменных с 4 или 6 суффиксами будет содержать только значения IPv6 или IPv4.

# сценарий разъединения получит дополнительные значения: 
# STATS_BYTES_IN, STATS_BYTES_OUT, STATS_DURATION, 
# которые содержат 64-разрядный счетчик вывода байтов от устройства tun и продолжительность сессии в секундах.

#connect-script = /usr/bin/myscript
#disconnect-script = /usr/bin/myscript

# UTMP
# Регистр связанные клиенты к utmp. Это позволит просматривать связанные клиенты, использующие команду 'who'.
#use-utmp = true

# Разрешить ли поддержку occtl инструмента (т.е. или через D-BUS, или через сокет Unix).
use-occtl = true

# файл PID. Это может быть переопределено в командной строке.
pid-file = /var/run/ocserv.pid

# Набор определенный протоколом приоритет (SO_PRIORITY) для пакетов, которые будут отправлены. 
# Это - число от 0 до 6 с 0 являющийся самым низким приоритетом. 
# Кроме того, это может использоваться для урегулирования Типа IP - Сервиса, путем урегулирования его в шестнадцатеричное число (например, 0x20).
# Это может быть установлено на пользователя/группу или глобально.
#net-priority = 3

# Набор рабочий процесс VPN в определенный cgroup. Это - конкретный Linux и может быть установлено за пользователя/группу или глобально.
#cgroup = "cpuset,cpu:test"

#
# Network settings
#

# имя для использования для tun устройства
device = vpns

# Будет ли сгенерированный IPs предсказуем, т.е. IP остается таким же для того же пользователя, если это возможно.
predictable-ips = true

# домен по умолчанию, который будет рекламироваться
default-domain = example.com

# пул адресов, от которых будут даны арендные договоры. 
# Если арендные договоры даны через Радиус, или через явный IP? опция конфигурации в расчете на пользователя 
# тогда эти сетевые значения должны содержать сеть, 
# по крайней мере с единственным адресом который останется под полным контролем от ocserv 
# (который должен быть в состоянии отвести локальную роль адреса устройства tun)
# Вы можете использовать адреса от подсети Вашей локальной сети, если Вы включаете [proxy arp в интерфейсе LAN] 
# (http://ocserv.gitlab.io/www/recipes-ocserv-pseudo-bridge.html);
# в этом случае рекомендуется установить арендные договоры ping true.
ipv4-network = 192.168.1.0
ipv4-netmask = 255.255.255.0

# альтернативный способ определить сеть:
#ipv4-network = 192.168.1.0/24

# подсеть IPv6, от которой будут даны арендные договоры.
#ipv6-network = fda9:4efe:7e3b:03ea::/48 

# Определяют размер сети для обеспечения клиентам. 
# Обычно рекомендуется предоставить клиентам/64 сеть в IPv6, но любая подсеть может быть определена. 
# Для обеспечения клиентов только единственным IP используют префикс 128.
#ipv6-subnet-prefix = 128
#ipv6-subnet-prefix = 64

# Туннелировать ли все запросы DNS через VPN. Это - значение по умолчанию, когда маршрут по умолчанию установлен.
#tunnel-all-dns = true

# распространенный сервер DNS. Используйте несколько строк для нескольких серверов.
# dns = fc00::4be0
dns = 192.168.1.2

# The NBNS server (if any)
#nbns = 192.168.1.3

# домены, по которым должен использоваться обеспеченный DNS. Используйте несколько строк для нескольких доменов.
#split-dns = example.com

# До аренды любого IP от пула проверяют его с помощью ping-запросов, чтобы проверить, что он не используется другим (не связаного с этим сервером) хостом.
# значение true только если там может быть заняты адреса арендные в диапазоне IP.
ping-leases = false

# эта опция используется чтобы установить значение MTU ссылки к входящим соединениям. Сброс для использования MTU по умолчанию устройства TUN.
# Заметьте, что MTU согласовывается с помощью набора значений и значения, отправленного одноранговым узлом.
#mtu = 1420

# Сброс для включения ограничений пропускной способности (в байтах/секунда). 
# Урегулирование здесь глобально, но может также быть установлено на пользователя или группу.
#rx-data-per-sec = 40000
#tx-data-per-sec = 40000

# количество пакетов (размера MTU), которые доступны в буфере вывода. Значение по умолчанию является низким для улучшения задержки.
# Урегулирование его выше улучшит пропускную способность.
#output-buffer = 10

# Маршруты, которые будут переданы клиенту. 
# При необходимости в клиенте для передачи маршрутов к серверу, можно использовать config-per-user/group или даже соединить и разъединить сценарии.
#
# Для урегулирования сервера как шлюз по умолчанию для клиента просто комментируют все маршруты с сервера или используют ключевое значение 'default'.

route = 10.10.10.0/255.255.255.0
route = 192.168.0.0/255.255.0.0
#route = fef4:db8:1000:1001::/64
#route = default

# Подмножества маршрутов выше этого не будут направлены сервером.

no-route = 192.168.5.0/255.255.255.0

# Заметьте, что следование за двумя опциями брандмауэринга в настоящее время доступно в системах Linux с iptables. 

# Если установлено, сценарий/usr/bin/ocserv-fw назовут, 
# чтобы ограничить пользователя его позволенными маршрутами и препятствовать тому, чтобы он получил доступ к любым другим маршрутам. 
# В случае defaultroute ограничиваются без маршрутов.
# Все маршруты, примененные ocserv, могут вернуться с помощью /usr/bin/ocserv-fw  --removeall. 
# Эта опция может быть установлена глобально или в конфигурации в расчете на пользователя.
#restrict-user-to-routes = true

# Эта опция подразумевает набор restrict-user-to-routes к истинному. 
# Если установлено, script /usr/bin/ocserv-fw назовут для ограничения пользователя для доступа к определенным портам в сети. 
# Эта опция может быть установлена глобально или в конфигурации в расчете на пользователя.
#restrict-user-to-ports = "tcp(443), tcp(80), udp(443), sctp(99), tcp(583), icmp(), icmpv6()"

# Вы могли также использовать отрицание, т.е. заблокировать пользователя от доступа к этим портам только.
#restrict-user-to-ports = "!(tcp(443), tcp(80))"

# Когда установлено в истинный, iroutes всего клиента сделаны видимыми всем соединительным клиентам за исключением тех предлагающих им. 
# Эта опция только имеет смысл, если в расчете на пользователя конфигурацией установлен.
#expose-iroutes = true

# Группы, из которых клиенту разрешают выбрать.
# клиент может принадлежать нескольких групп, и определенных примеров использования необходимо переключиться между ними. 
# Для этих случаев клиент может выбрать до аутентификации. Добавьте многократные въезды для нескольких групп.
# группа может сопровождаться удобным для пользователя именем в скобках.
#select-group = group1
#select-group = group2[My special group]

# имя (виртуальной) группы, что, если выбрано это присвоило бы пользователя своей группе по умолчанию.
#default-select-group = DEFAULT

# Вместо того, чтобы определить вручную все разрешенные группы, можно дать ocserv команду сканировать все доступные группы и включать полный список.
#auto-select-group = true

# Конфигурационные файлы, которые будут применены за пользовательское соединение или за группу. 
# Каждое имя файла на этих каталогах должно соответствовать имени пользователя или groupname.
# опции, позволенные в конфигурационных файлах, являются dns, nbns,  ipv?-network, ipv4-netmask, rx/tx-per-sec, iroute, route, no-route,  
# explicit-ipv4, explicit-ipv6, net-priority, deny-roaming, no-udp, keepalive, dpd, mobile-dpd, max-same-clients, tunnel-all-dns,  
# restrict-user-to-routes, user-profile, cgroup, stats-report-time, mtu, idle-timeout, mobile-idle-timeout, restrict-user-to-ports, 
# and session-timeout.
#
# Примечание, что опция 'iroute' позволяет добавлять маршруты на сервере на основе пользователя или группы. 
# Синтаксис зависит от входа, принятого командами route-add-cmd и route-del-cmd (см. ниже). 
# no-udp параметр (например, no-udp = true), и предотвратит сеанс UDP для определенного пользователя или группы. 
# Опция имени узла установит имя узла переопределять любого предложенного пользователем. 
# Отметьте также, что, any routes, no-routes, DNS или существующие серверы NBNS, перезапишут глобальные.

#config-per-user = /etc/ocserv/config-per-user/
#config-per-group = /etc/ocserv/config-per-group/

# Когда config-per-xxx определяется и нет никакой группы или пользователя, который соответствует, затем используйте следующую конфигурацию.
#default-user-config = /etc/ocserv/defaults/user.conf
#default-group-config = /etc/ocserv/defaults/group.conf

# системная команда для использования для установки маршрута. % {R} будет заменен
# route/mask, %{RI} with the route in CIDR format, and %{D} with the (tun) device.
#
# следующий пример от систем Linux. % {R} должен быть чем-то
# like 192.168.2.0/255.255.255.0 and %{RI} 192.168.2.0/24 (the argument of iroute).

#route-add-cmd = "ip route add %{R} dev %{D}"
#route-del-cmd = "ip route delete %{R} dev %{D}"

# Эта опция позволяет передавать прокси. 
# Специальные ключевые слова '% {U}' и '% {G}', если существующий будет заменен именем пользователя и названием группы.
#proxy-url = http://example.com/
#proxy-url = http://example.com/%{U}/

# Эта опция позволяет Вам определять местоположение URL, где клиент может отправить MS-KKDCP использования, 
# и сообщение будет передано к обеспеченному серверу KDC. Это - URL перевода между HTTP и Kerberos.
# В MIT kerberos необходимо будет добавить в областях:
#   EXAMPLE.COM = {
#     kdc = https://ocserv.example.com/KdcProxy
#     http_anchors = FILE:/etc/ocserv-ca.pem
#   }
# В некоторых дистрибутивах krb5-k5tls требуется плагин kinit.
#
# следующая опция доступна в ocserv, когда скомпилировано с поддержкой GSSAPI.

#kkdcp = "SERVER-PATH KERBEROS-REALM PROTOCOL@SERVER:PORT"
#kkdcp = "/KdcProxy KERBEROS.REALM udp@127.0.0.1:88"
#kkdcp = "/KdcProxy KERBEROS.REALM tcp@127.0.0.1:88"
#kkdcp = "/KdcProxy KERBEROS.REALM tcp@[::1]:88"

# Клиентский профиль xml. Это может использоваться для рекламы альтернативных серверов клиенту. Минимальный файл может быть:
# <?xml version="1.0" encoding="UTF-8"?>
# <AnyConnectProfile xmlns="http://schemas.xmlsoap.org/encoding/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://schemas.xmlsoap.org/encoding/ AnyConnectProfile.xsd">
#   <ServerList>
#       <HostEntry>
#               <HostName>VPN Server name</HostName>
#               <HostAddress>localhost</HostAddress>
#       </HostEntry>
#   </ServerList>
# </AnyConnectProfile>
#
# Поля могут использоваться некоторыми клиентами CISCO.
# Этот файл должен быть доступным из chroot рабочего. 
# Не рекомендуется включение этой опции, поскольку это позволит рабочим процессам открывать произвольные файлы (когда изолированные рабочие будет иметь значение true).
#user-profile = profile.xml

# следующие опции для (экспериментальной) клиентской совместимости AnyConnect.

# Эта опция включит pre-draft-DTLS версию DTLS и не потребует, чтобы клиенты представили свой сертификат на каждом соединении TLS. 
# Это должно иметь значение true для поддержки клиентов CISCO прежней версии и openconnect клиентов <7.08. 
# Когда установлено в истинный, это подразумевает dtls-legacy = true.
cisco-client-compat = true

# Эта опция позволяет отключать согласование DTLS-PSK (включено по умолчанию).
# согласование DTLS-PSK было представлено в ocserv 0.11.5 для осуждения pre-draft-DTLS согласования, наследованного от AnyConnect. 
# Это позволяет канал DTLS для согласования его шифров и версии протокола DTLS.
#dtls-psk = false

# Эта опция позволяет отключать согласование DTLS прежней версии (включено по умолчанию, но это может измениться в будущем).
# DTLS прежней версии использует предварительную предварительную версию протокола DTLS и была из протокола AnyConnect. 
# Это имеет несколько ограничений, которые обращены dtls-psk протоколом, поддерживаемым openconnect 7.08.
dtls-legacy = true

#Advanced options

# Опция позволить отправлять произвольные пользовательские заголовки клиенту после аутентификации и до туннельного установления VPN. 
# Обычно вы не должны использовать эту опцию; 
# если Вы делаете и Вы думаете, что это может помочь другим, отправьте свои параметры настройки и причину для openconnect списка рассылки. 
# Специальные ключевые значения '% {U}' и '% {G}', если существующий будет заменен именем пользователя и названием группы.
#custom-header = "X-My-Header: hi there"


# пример виртуальный хост с различными методами аутентификации, обслуживаемыми этим сервером.

[vhost:www.example.com]
auth = "certificate"

ca-cert = ../tests/certs/ca.pem

# набор сертификата здесь должен включать 'dns_name', соответствующий виртуальному имени хоста.

server-cert = ../tests/certs/server-cert-secp521r1.pem
server-key = ../tests/certs/server-key-secp521r1.pem

ipv4-network = 192.168.2.0
ipv4-netmask = 255.255.255.0

cert-user-oid = 0.9.2342.19200300.100.1.1

